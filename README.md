# 记录遇到的一些前端面试题
## css
### 一个div设置为“标准模型”，同时设置它的背景颜色为红色。那么背景色会覆盖哪些区域呢？
- 会覆盖content、padding区域。这边其实跟是“标准模型”还是“IE模型”没有关系。

### css中选择器的优先级
- 标签选择器(p) < 类选择器(.example)、属性选择器([type='radio']) < ID选择器(#example);
- 关系选择符(~,+,>)、通配符(*)对优先级没有影响；
- 越具体的规则，优先级越高。比如p span{}会比p{}和span{}的优先级更高；
- !important可以将优先级提到最高，但其实不太建议用它。建议通过样式规则来调整最终的效果；

### position:absolute绝对定位
- 位置是相对于含有`position:relative`、`position:absolute`或者`position:fixed`样式的父节点的位置；
- 如果父节点没有该样式，则逐级往上，直到某个父节点有该样式，或者到body元素；
- 绝对定位时，位置是相对于符合条件的父元素或者body元素的padding的左上角进行定位的。

## js
### this指针
- 一般情况下，this指向最终调用的对象；
- 箭头函数()=>{}中的this指针是在定义时确定，执行定义时的上下文；
- bind、call、apply等可以改变this指针的指向；
- 严格模式下，全局对象是undefined；
```js
var obj1 = {
    age: 10,
    getAge: function () {
        console.log(this.age);
    }
};

var obj2 = {
    age: 20,
};

var getAge = obj1.getAge;
obj2.getAge = obj1.getAge;

// 此时this指向全局对象window。
// 因为window下没有定义age，所以会打印出undefined.
// 如果是严格模式下，全局对象是undefined，
// 所以会报错，而不是打印出undefined
getAge();

// 此处是将obj1.getAge函数传入到setTimeout中，
// 具体调用还是window，即window.setTimeout。
// 所以此时this是指向全局对象window.
// 因为window下没有定义age，所以会打印出undefined
setTimeout(obj1.getAge, 100);

// 因为上文中已经在obj2中新增了getAge函数。
// 此时调用getAge函数的是obj2。所以此时this指向obj2
// 所以打印的值为20.
obj2.getAge();
```

### call，apply和bind的区别：
- 这3个都可以改变函数中this指向的对象；
- call和apply是在改变this指向的对象时，同时执行函数；bind是返回改变this指向的对象后的函数，该函数并没有被执行；
- call和apply的区别是参数的传入方式不同。它们的第一个参数都是this指向的对象，第二个参数开始，call传入参数是一个一个的传如剩余参数，apply是将剩余参数放在一个数组中一次传入；

### 防抖和节流
- 防抖就是前后两次触发的间隔要大于规定的时间。如果小于规定的时间，就以最新的一次触发为准，重新开始计时；
- 节流是规定的时间内只触发一次，同时触发的为最后的值或者事件；

### 浏览器安全
#### xss跨站脚本攻击：在html中插入攻击代码，用户在访问页面的时候攻击代码被执行，从而导致被攻击；
- 永远不相信用户输入的内容，因此对用户的输入进行转义、过滤，避免被插入恶意的js代码；
- 使用https协议；
- 在cookie中设置httpOnly,这样cookie就无法通过js访问获取，提升cookie安全性；

### xsrf跨站请求伪造：在用户登录后，假借用户的身份向服务器发送一些请求，执行一些操作，达到攻击的目的；
- 过程：
1. 用户访问网站A，并成功登录；
2. 用户被诱导访问攻击者服务器B，B返回一段恶意代码给用户；
3. 用户浏览器上接收到这段恶意代码，并悄悄执行，在用户不知道的情况下向网站A发送一些请求；
4. 因为用户已经登录过，所以发送的请求会带上cookie之类的身份验证信息，网站A就会以为这些请求是用户发送的，以用户的身份权限进行操作；
- 防范措施：
1. 使用token，可以因此在请求头中

### js加载
- 不加任何属性，即`<script src="./a.js"></script>`.这种js加载方式，会阻塞页面的渲染，直到它加载并执行完，页面的渲染才会继续；
- 加async属性,即`<script src="./a.js" async></script>`.这种js加载方式，在js加载时不会阻塞页面的渲染。但是当js加载完时，会优先执行js中的内容。在js中的内容执行完后，才会继续页面的渲染；
- 加defer属性,即`<script src="./a.js" defer></script>`.这种js加载方式，不管是在js加载时，还是js加载完成后都不会阻塞页面的渲染。在页面渲染完毕后，才会执行js中的内容；

### http缓存
- 强缓存：符合缓存条件时，会直接使用缓存中的数据，而不会向服务器发起http请求；
1. expired和cache-control;
2. expired是http1.0的产物，是否使用缓存的条件是expired指定的过期时间。当大于过期时间时，会向服务器发起请求，否则直接使用缓存中的数据。但是时间判定时是获取浏览器本地的时间和过期时间做对比，而本地时间容易被调整；
3. cache-control是http1.1的产物，通过max-age指定数据有效时长，单位为s。因为并不是通过本地时间来判断，所以会比expired好。
4. cache-control中还有其它属性。常用的有：private:只能浏览器缓存，代理服务器不能缓存；public为代理服务器也能缓存；no-cache:不使用强缓存，使用协商缓存；no-store:完全不使用缓存

- 协商缓存：会向服务器发起请求。服务器验证数据是否有更新。有的话返回200状态码和新的数据；没有更新的话，返回304和空响应体，浏览器直接使用缓存中的数据；
1. Last-Modify和Etag;
2. Last-Modify是数据最后一次修改的时间。当浏览器请求时会带上上次的last-modify，放在请求头的last-modufy-since字段中。服务器接收到后验证数据是否相同。如果不同，返回200、新的数据和最新的last-modify;
3. Etag是数据的唯一标识。数据每次改变都会重新生成一个新的Etag。当浏览器请求时会带上上次的Etag。服务器接收到后验证是否相同。如果不同，则返回200、新的数据和最新的Etag；
4. last-modify的优点是对服务器压力小，是根据s秒来计算有效时间的。如果这个时间段内发生多次修改，last-modify无法记录到。
5. etag是数据发生变化时根据算法重新生成的，对服务器压力会大一点。
6. 优先级上，如果两者同时存在，则etag优先级比较高；

- 缓存的位置：缓存位置主要在service worker、内存和硬盘中
1. service worker是pwa实现的重要机制。它是运行在浏览器背后的独立线程，脱离了浏览器窗体。因此它无法访问dom。它主要实现了离线缓存、网络代理和消息推送等。因为它能够实现网络代理拦截，所以安全性要求比较高，需要https
2. 内存缓存，是将缓存数据放在内存中。这种方式的优点是读取速度快，缺点是保存时间不长，页面关闭后即释放，以及无法缓存太多内容。当内存吃紧时，缓存数据容易被清除以便回收内存。它一般用于缓存一些需要多次访问的小数据
3. 硬盘缓存，是将缓存数据放在硬盘中。这种方式能够长久保存缓存数据，不容易被清除。缺点时访问速度相对来说会慢一点。一般用于缓存大数据

### 从输入url到页面展示，这个过程中发生的事情
- 进行dns解析。根据输入的url解析获取到服务器地址。dns解析的结果一般会缓存下来，以便下次访问时不用再重新解析，加快访问速度；

- 进行tcp链接，以便发起http请求

- 发起http请求，向服务器发送请求

- 服务器响应请求数据。常见的响应状态码：
1. 1xx:请求已接受，浏览器继续相关请求；
2. 2xx:请求被成功接收，并处理。200是请求成功;204是not content,表示请求已成功，但是没有返回内容
3. 3xx:表示重定向。301是永久移动到新位置，302是临时移动到新位置，304是内容没有变化，直接使用缓存
4. 4xx:表示客户端错误。400表示错误请求，比如请求语法问题；401表示没验证，需要先验证身份才能继续访问；403表示没权限，用户虽然已经验证身份，但是没有访问该数据的权限;404表示没找到
5. 5xx:服务器问题。500表示服务器内部错误；502是bad getway,网关错误；503是服务器不可用；504是getway timeout网关超时；

- 浏览器接收响应数据并开始渲染页面
1. 浏览器解析html文件生成dom树；
2. 浏览器解析css文件生成样式规则
3. 将dom树和样式规则结合生成渲染树；
4. 根据渲染树进行reflow回流（重排），计算每个dom元素的位置、大小等
5. 进行repain重绘，计算每个dom元素的文字、背景颜色等
6. 在浏览器中渲染出来